{
    "questions" :[
         {
             "id": 0,
             "name": "1",
             "question": "Что такое React?",
             "answer": "React - это JavaScript-библиотека, предназначенная для создания быстрых и интерактивных пользовательских интерфейсов (user interfaces, UI) для веб- и мобильных приложений. Это открытая (с открытым исходным кодом), основанная на компонентах, библиотека для фронтенда, отвечающая только за слой представления (view layer) приложения.Основная задача React - разработка быстрых пользовательских интерфейсов. В нем используется виртуальная объектная модель документа (virtual document object model (DOM) - программный интерфейс приложения (application programming interface (API)), для HTML и XML-документов. Он определяет логическую структуру документа, способы доступа к документу и управления им. Виртуальный DOM - это JavaScript-объект), что повышает производительность приложения. Виртуальный DOM быстрее обычного (браузерного). Мы можем использовать React как на стороне клиента, так и на стороне сервера, а также вместе с другими фреймворками. В нем используются компоненты и различные паттерны проектирования для работы с данными, что улучшает читаемость кода и облегчает поддержку больших приложений."
             
         },
         {
            "id": 1,
            "name": "2",
            "question": "Что такое JSX и как он помогает разрабатывать приложения?",
            "answer": "JSX позволяет создавать HTML-элементы прямо в JavaScript и помещать их в DOM без использования таких методов, как createElement() или appendChild(). JSX преобразует HTML-теги в элементы React. React использует JSX для шаблонизации вместо обычного JavaScript. Использовать JSX не обязательно, однако он предоставляет несколько преимуществ:Он быстрее благодаря оптимизации во время компиляции кода в JavaScriptОн также является типобезопасным, большинство ошибок перехватываются во время компиляцииОн позволяет легче и быстрее создавать шаблоны"
        },
        { "id": 2,
            "name": "3",
            "question": "Что такое чистый компонент (Pure Component)?",
            "answer": "Pure Components - это компоненты, которые не рендерятся повторно при обновлении их состояния и пропов одними и теми же значениями. Если значение предыдущего и нового состояния и пропов равны, компонент не отрисовывается повторно. Чистые компоненты ограничивают повторный рендеринг, обеспечивая повышение производительности приложения."
        },
        {
            "id": 3,
            "name": "4",
            "question": "setState асинхронная или синхронная?",
            "answer": "Асинхронная   Это связано с тем, что setState() изменяет состояние и приводит к повторному рендерингу. Если операция обновления состояние будет синхронной и при этом дорогой с точки зрения производительности, то браузер пользователя лишится интерактивности (перестанет отвечать на действия пользователя до завершения операции). Поэтому такие операции являются асинхронными и группируются для обеспечения лучшего пользовательского опыта и повышения производительности."
        },
        {
           "id": 4,
           "name": "5",
           "question": "Что такое Виртуальная DOM?",
           "answer": "Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием. Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире React «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, React также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в React."
       },
       { "id": 5,
           "name": "6",
           "question": "Для чего нужен атрибут key при рендере списков?",
           "answer": "Ключи (keys) помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени. Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи. Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ."
       },
       { "id": 6,
           "name": "7",
           "question": "Что такое Компонент высшего порядка (Higher-Order Component, HOC)?",
           "answer": "Говоря просто, компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент. HOC часто встречаются в сторонних библиотеках, например connect в Redux и createFragmentContainer в Relay."
       },
       { "id": 7,
        "name": "8",
        "question": "Какие методы может иметь HTTP-запрос?",
        "answer": "GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные. HEAD запрашивает ресурс так же, как и метод GET, но без тела ответа. POST используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере. PUT заменяет все текущие представления ресурса данными запроса. DELETE удаляет указанный ресурс. CONNECT устанавливает туннель к серверу, определённому по ресурсу. OPTIONS используется для описания параметров соединения с ресурсом. TRACE выполняет вызов возвращаемого тестового сообщения с ресурса. PATCH используется для частичного изменения ресурса."
       },
       { "id": 8,
        "name": "9",
        "question": "Что такое Cross-Origin Resource Sharing (CORS)?",
        "answer": "Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом. В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки."
       },
       { "id": 9,
        "name": "10",
        "question": "Какие типы данных существуют в JavaScript?",
        "answer": "Число «number» - Единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений). Например, бесконечность Infinity получается при делении на ноль. Ошибка вычислений NaN будет результатом некорректной математической операции. Строка «string» Булевый (логический) тип «boolean» Специальное значение «null» - В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно». Специальное значение «undefined» - Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined. Символы «symbol» - «Символ» представляет собой уникальный идентификатор. Создаются новые символы с помощью функции Symbol(). Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет. Объекты «object» - Первые 5 типов называют «примитивными». Особняком стоит шестой тип: «объекты». Он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок {...}"
       },
       { "id": 10,
        "name": "11",
        "question": "Что такое замыкание?",
        "answer": "Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания. БОЛЕЕ простой ОТВЕТ Если одна функция определена внутри другой, то внутренняя имеет доступ к ОВ внешней. Это называется замыканием (а также лексической ОВ или статическая. При выполнении функции используется та область видимости переменных, которая существовала на момент объявления этой функции. Это лексическая область видимости."
       },
       { "id": 11,
        "name": "12",
        "question": "Что такое прототип объекта в JavaScript?",
        "answer": "Объекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически искалось бы в другом. Связующим звеном выступает специальное свойство __proto__  Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__. Недостаток этого подхода – он не работает в IE10-.  К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ. Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.   При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.  Значением Person.prototype по умолчанию является объект с единственным свойством constructor, содержащим ссылку на Person."
       },
       { "id": 12,
        "name": "13",
        "question": "Как работает ключевое слово this?",
        "answer": "В глобальном контексте выполнения (за пределами каких-либо функций), this ссылается на глобальный объект вне зависимости от использования в строгом или нестрогом режиме.  В пределах функции значение this зависит от того, каким образом вызвана функция:  Простой вызов - В этом случае значение this не устанавливается вызовом. Так как этот код написан не в строгом режиме, значением this всегда должен быть объект, по умолчанию - глобальный объект. В строгом режиме, значение this остается тем значением, которое было установлено в контексте исполнения. Если такое значение не определено, оно остается undefined. Для того что бы передать значение this от одного контекста другому необходимо использовать call или apply  В стрелочных функциях, this привязан к окружению, в котором была создана функция. В глобальной области видимости, this будет указывать на глобальный объект.   Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово this принимает значение объекта, по отношению к которому вызван метод."
       },
       { "id": 13,
        "name": "14",
        "question": "Как работают методы apply(), call() и bind()?",
        "answer": "Функции в JavaScript никак не привязаны к своему контексту this, с одной стороны, здорово – это позволяет быть максимально гибкими, одалживать методы и так далее.   Но с другой стороны – в некоторых случаях контекст может быть потерян. Способы явно указать this - методы bind, call и apply.    Синтаксис метода call: func.call(context, arg1, arg2, ...)  При этом вызывается функция func, первый аргумент call становится её this, а остальные передаются «как есть». Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), но с явно указанным this(=context).   Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply. Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.   func.call(context, arg1, arg2) идентичен вызову func.apply(context, [arg1, arg2]);   Синтаксис встроенного bind: var wrapper = func.bind(context[, arg1, arg2...])   Методы bind и call/apply близки по синтаксису, но есть важнейшее отличие. Методы call/apply вызывают функцию с заданным контекстом и аргументами. А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом."
       },
       { "id": 14,
        "name": "15",
        "question": "Что такое Promise (Промис)?",
        "answer": "Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»)."
       },
       { "id": 15,
        "name": "16",
        "question": "Что такое Set, Map, WeakSet и WeakMap?",
        "answer": "Map – коллекция для хранения записей вида ключ:значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз. WeakSet – особый вид Set, не препятствующий сборщику мусора удалять свои элементы. То же самое – WeakMap для Map. То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти. Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект. Например, у нас есть элементы на странице или, к примеру, пользователи, и мы хотим хранить для них вспомогательную информацию, например обработчики событий или просто данные, но действительные лишь пока объект, к которому они относятся, существует. Если поместить такие данные в WeakMap, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент."
       }
       ,
       { "id": 16,
        "name": "17",
        "question": "Объясните делегирование событий.",
        "answer": "Всплытие событий позволяет реализовать один из самых важных приёмов разработки - делегирование.  Он заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому - мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент event.target, понять на каком потомке произошло событие и обаботать его.  Алгоритм:    Вешаем обработчик на контейнер.   В обработчике: получаем event.target.   В обработчике: если event.target или один из его родителей в контейнере (this) – интересующий нас элемент – обрабатываем его.   Зачем использовать:      Упрощает инициализацию и экономит память: не нужно вешать много обработчиков. Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.  Удобство изменений: можно массово добавлять или удалять элементы путём изменения innerHTML."
       }
       ,
       { "id": 17,
        "name": "18",
        "question": "Объясните, как this работает в JavaScript.",
        "answer": "Использование this гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана, если это не стрелочная функция. У стрелочных функций контекст this определяется в момент создания функции.   Значение this называется контекстом вызова и будет определено в момент вызова функции. Значением this является объект перед точкой, в контексте которого вызван метод."
       }
       ,
       { "id": 18,
        "name": "19",
        "question": "В чём различие между переменными, значение которых: null, undefined и не объявлено?",
        "answer": "undefined - это переменная, которая была объявлена, но у нее нет значения. null - значение переменной.    undeclared - переменная, объявленная без ключевого слова 'var'.  Для проверки можно использовать console.log() и typeof."
       }
       ,
       { "id": 19,
        "name": "20",
        "question": "Можете ли вы описать основное различие между циклом forEach и циклом .map()? И в каких случаях каждый из них используется?",
        "answer": "forEach перебирает массив и изменяет его. .map() создает копию массива и изменяет копию."
       }
       ,
       { "id": 20,
        "name": "21",
        "question": "В каких случаях обычно используются анонимные функции?",
        "answer": "Анонимные функции часто используются для выполнения какого-то кода в коллбэках, где не нужно создавать отдельную именную функцию под это действие."
       }
       ,
       { "id": 21,
        "name": "22",
        "question": "В чем разница между: function Person(){}, var person = Person(), и var person = new Person()?",
        "answer": "function Person(){} - Мы создаем функцию с именем Person.  var person = Person() - Мы вызываем функцию Person и результат сохраняем в переменную person.  var person = new Person() - Мы создаем новый объект, используя функцию-конструктор Person."
       }
       ,
       { "id": 22,
        "name": "23",
        "question": "Опишите весь процесс, начиная с ввода адреса сайта в адресную строку до окончания его загрузки на экране.",
        "answer": "Вы вводите адрес в строку адреса в браузере. Браузер ищет в своём кэше запись о DNS сервере соответствующего IP-адреса.  DNS (Domain Name System) — это база данных с url-адресами сайтов и связанными с ними IP. Каждый URL в интернете имеет свой уникальный IP. IP адрес принадлежит компьютеру, на котором находится сервер запрашиваемого вебсайта.  Чтобы найти запись DNS браузер проверяет 4 кэша:  Кэш браузера. У браузера есть хранилище DNS записей для сайтов, на которых вы уже были.  Кэш операционной системы. Если в кэше браузера нет записи о DNS, браузер делает системный запрос к операционной системе, у которой есть свой кэш DNS записей. Кэш роутера. Если браузер ничего не нашёл на компьютере, он делает запрос к роутеру, у которого есть свой DNS кэш. Кэш провайдера. Если предыдущие попытки закончились неудачей, браузер обращается к кэшу провайдера. Если запрашиваемого URL нет в кэше, DNS сервер провайдера отправляет DNS запрос серверу, на котором хостится необходимый вебсайт. DNS запрос ищет нужный IP на разных DNS серверах. Такой поиск называется рекурсивным, потому что переходит от сервера к серверу, пока не найдет IP или не вернёт ошибку о невозможности его найти. DNS запросы отправляют небольшие пакеты данных с информацией о содержимом запроса и IP адресом, откуда это запрос пришел (IP адрес провайдера). Если эти пакеты теряются, выводится ошибка. При нахождении нужного DNS сервера пакеты берут верный IP адрес и возвращают его браузеру.  Браузер инициализирует TCP соединение с сервером. Как только браузер получил верный IP адрес, он создаёт соединение для передачи информации. В большинстве случаев браузеры используют TCP протокол для любых HTTP запросов. Для соединения с сервером используется процесс TCP/IP three-way handshake - трёхшаговый процесс, в котором клиент и сервер обмениваются SYN (synchronize) и ACK (acknowledge) сообщениями. Компьютер клиента посылает серверу SYN запрос, чтобы узнать открыт ли сервер для новых соединений. Если у сервера есть открытые порты для новых соединений, он отвечает пакетом SYN/ACK. Клиент получает от сервера SYN/ACK пакет и подтверждает соединение, отослав ACK пакет.  После этого TCP соединение установлено.  Браузер посылает HTTP запрос к web серверу. Браузер отсылает GET запрос для нужной веб страницы. Если мы отправляем форму, это будет POST запрос. Этот запрос содержит дополнительную информацию о браузере (заголовок User-Agent), типы запросов, которые он может принять (Accept заголовок) и заголовки соединения (нужно ли сохранять соединение). Также в запросе будет информация о cookies, которые браузер хранит для этого домена.     Сервер обрабатывает запрос и даёт ответ. Сервер получает запрос и передаёт его обработчику запросов для чтения и создания ответа. Обработчик запроса — это программа (написанная на PHP, Ruby и т.д.), которая читает запрос, заголовки и cookies, распознаёт, какая информация запрошена и обновляет данные на сервере, если необходимо. Далее собирается ответ в определённом формате (JSON, XML, HTML).        Сервер высылает HTTP ответ.        Ответ сервера содержит запрошенную веб страницу вместе с кодом статуса, типом сжатия (Content Encoding), информацией о том, как кэшировать страницу, cookies и т.д.        В первой строчке ответа находится код статуса. Существует 5 типов:        1xx содержит только информационное сообщение    2xx указывает на успешный запрос    3xx переадресует клиента на другой URL    4xx указывает на ошибку на стороне клиента    5xx указывает на ошибку на стороне сервера    Таким образом, если вы столкнулись с ошибкой, вы можете посмотреь на HTTP ответ и проверить код, который вы получили.        Браузер отображает HTML контент.    Браузер отображает HTML контент в несколько стадий.        Рендерит HTML разметку.    Проверяет HTML теги и отсылает GET запросы за дополнительными элементами (изображениями, css-файлами, JavaScript и т.д.). Эти файлы браузер кэширует, чтобы не скачивать их, когда вы зайдёте на этот сайт в следующий раз.  Отображает запрошенную страницу у вас в браузере."
       }
       ,
       { "id": 23,
        "name": "24",
        "question": "Назовите основные этапы жизненного цикла компонента",
        "answer": "componentWillMount - перед рендерингом, в основном для настройки компонента    render - процесс рендеринга    componentDidMount - уведомляет, про то, что компонент соединен с DOM деревом    componentWillReceiveProps - уведомляет, про то, что приходят новые входящие свойства в компонент    shouldComponentUpdate - возвращает true или false и служит для оптимизации. Решает, нужно ли делать ре-рендеринг    componentWillUpdate - уведомляет, что компонент будет обновлен    componentDidUpdate - уведомляет, что компонент был обновлен    componentWillUnmount - используется для удаления слушателей и очисткикомпонента. Вызывается перед удалением компонента"
       }
      
    ]
    }